# Mersenne-lottery 

| Событие         | Название     | Категория |
| :-------------- | ------------ | --------- |
| StudentCTF 2025 | Mersenne-lottery | CRYPTO       |


## Описание

>Не упустите возможность стать частью этого увлекательного события. Участвуйте в нашей лотерее, и, возможно, удача улыбнется именно вам! Мы уверены, что это будет незабываемый опыт, который подарит вам радость и надежду на победу. Присоединяйтесь к нам и испытайте свою удачу!
>

## Решение

Нам дан сервис, в котором нам предлагается секция хинт, чтобы узнать какие-то числа, а затем угадать 16 случайных значений от 0 до 255 для получения флага в качестве финального приза, звучит как что-то нереальное.

Изучаем подробно исходный код. В секции "Хинт" нам предлагается на наш выбор узнать от 0 до 32 значений вывода random.getrandbits(32) от 0 до 2024. Вспоминаем, что random.getrandbits(32) - вывод состояния [Вихря Мерсенна](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%85%D1%80%D1%8C_%D0%9C%D0%B5%D1%80%D1%81%D0%B5%D0%BD%D0%BD%D0%B0). Для восстановления seed, который не задан, потребуется ровно 624 последовательных состояния!!! Поэтому отметаем вариант решения через восстановление seed.

Далее видим, что требуется угадать вывод random.choices([i for i in range(256)], k=16), поэтому дальше необходимо разобраться в том, как именно он работает. Предполагаем, что для random.choices также используются очередные состояния генератора Мерсенна. Для этого напишем небольшой код:

```python3
from random import Random

r1 = Random(12345)
for i in range(36):
    print(f"{i+1}) {r1.getrandbits(32)}")

print()
r2 = Random(12345)
print(f"1) {r2.getrandbits(32)}")
print(f"2) {r2.getrandbits(32)}")
print(r2.choices([i for i in range(256)], k=16))
print(f"n) {r2.getrandbits(32)}")
```
И посмотрим его вывод:

```
1) 1789368711
2) 3146859322
3) 43676229
4) 3522623596
5) 3544234957
6) 3448207591
7) 1282648386
8) 3672791226
9) 1582316135
10) 4001984784
11) 831769172
12) 1160692746
13) 2430986565
14) 1873586768
15) 694443915
16) 1602297017
17) 533722196
18) 3754550193
19) 1859447115
20) 1121373020
21) 2414108708
22) 2693866766
23) 748799881
24) 2627529228
25) 2376066489
26) 802338724
27) 1524289825
28) 3170323834
29) 4114856911
30) 3147651300
31) 392105170
32) 2280811246
33) 4203226770
34) 3158478146
35) 1770039327
36) 2512780184

1) 1789368711
2) 3146859322
[2, 211, 76, 94, 49, 144, 41, 31, 110, 143, 44, 141, 90, 245, 23, 250]
n) 1770039327
```
Заметим, что было пропущено ровно 32 последовательных члена последовательности сгенерированных чисел. n-ый член последовательности является 35-ым. Поменяем параметр k последовательно на 1, 2, 3, ... в random.choices и заметим, что задействованы всегда будут 2k членов последовательности вывода генератора. Осталось только разобраться, как получается итоговый вывод.

На самом деле, тут все легко. Если рассматривать на данном примере, то берется состояние генератора 3, 5, 7 и т.д. через одно и делится на 2^(24) или сдвигается на 24 бита вправо. Получаем, что выводом являются 8 старших бит состояния.

Также рассмотрим устройство Вихря Мерсенна в Python:

На основе seed составляется последовательность из 624 32-битных чисел. Далее каждый последующий i-ый член последовательности формируется на основе двух предыдущих: (i+1) % 624 и (i+397) % 624. То есть, для 625-го элемента потребуется 2-ой и 398-ой элементы. При этом берутся только последние 624 элемента.

У нас в задаче необходимо найти 2025, 2027, 2029 и т.д. до 2055 члены последовательности. Для этого нам понадобится 32 элемента из предыдущих 624 состояний, а именно для 2025 члена - 1402 и 1798, для 2027 - 1404 и 1800, для 2029 - 1406 и 1802 и т.д.

Также не забываем найти где-нибудь исходный код самого генератора, куда будем подавать наши элементы для получения нужных элементов, причем вывод будет состоять из двух 32-битных значений, вероятность 50/50 угадать нужный, но в задаче как раз дается 2 попытки.

Решение представлено на языке [Python](sploit.py).

### Флаг

```
stctf{guessing_the_conclusion_of_random.choiches_was_fun_and_easy_wasn't_it?}
```